// qpair.sip generated by MetaSIP
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2015 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt4.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


// QPair<int, int> is implemented as a Python 2-element tuple.
%MappedType QPair<int, int> /DocType="tuple-of-int-int"/
{
%TypeHeaderCode
#include <qpair.h>
%End

%ConvertFromTypeCode
    // Create the tuple.
    return Py_BuildValue((char *)"ii", sipCpp->first, sipCpp->second);
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
        return (PyTuple_Size(sipPy) == 2);

    QPair<int, int> *qp = new QPair<int, int>;
 
    qp->first = SIPLong_AsLong(PyTuple_GET_ITEM(sipPy, 0));
    qp->second = SIPLong_AsLong(PyTuple_GET_ITEM(sipPy, 1));

    *sipCppPtr = qp;
 
    return sipGetState(sipTransferObj);
%End
};
// QPair<unsigned, unsigned> is implemented as a Python 2-element tuple.
%MappedType QPair<unsigned, unsigned> /DocType="tuple-of-int-int"/
{
%TypeHeaderCode
#include <qpair.h>
%End

%ConvertFromTypeCode
    // Create the tuple.
    return Py_BuildValue((char *)"II", sipCpp->first, sipCpp->second);
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
        return (PyTuple_Size(sipPy) == 2);

    QPair<unsigned, unsigned> *qp = new QPair<unsigned, unsigned>;
 
    qp->first = PyLong_AsUnsignedLong(PyTuple_GET_ITEM(sipPy, 0));
    qp->second = PyLong_AsUnsignedLong(PyTuple_GET_ITEM(sipPy, 1));

    *sipCppPtr = qp;
 
    return sipGetState(sipTransferObj);
%End
};
%If (Qt_4_5_0 -)
// QPair<TYPE, int> is implemented as a Python 2-element tuple.
template<TYPE>
%MappedType QPair<TYPE, int> /DocType="tuple-of-TYPE-int"/
{
%TypeHeaderCode
#include <qpair.h>
%End

%ConvertFromTypeCode
    // Create the tuple.
    PyObject *tup = PyTuple_New(2);

    if (!tup)
        return 0;

    PyObject *obj;

    // Convert the first part.
    TYPE *t = new TYPE(sipCpp->first);

    obj = sipConvertFromNewType(t, sipType_TYPE, sipTransferObj);

    if (!obj)
    {
        delete t;

        Py_DECREF(tup);
        return 0;
    }

    PyTuple_SET_ITEM(tup, 0, obj);

    // Convert the second part.
    obj = SIPLong_FromLong(sipCpp->second);

    if (!obj)
    {
        Py_DECREF(tup);
        return 0;
    }

    PyTuple_SET_ITEM(tup, 1, obj);

    return tup;
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
        return (PyTuple_Size(sipPy) == 2 && sipCanConvertToType(PyTuple_GET_ITEM(sipPy, 0), sipType_TYPE, SIP_NOT_NONE));

    QPair<TYPE, int> *qp = new QPair<TYPE, int>;

    int state;
    TYPE *t = reinterpret_cast<TYPE *>(sipConvertToType(PyTuple_GET_ITEM(sipPy, 0), sipType_TYPE, sipTransferObj, SIP_NOT_NONE, &state, sipIsErr));

    if (*sipIsErr)
    {
        sipReleaseType(t, sipType_TYPE, state);

        delete qp;
        return 0;
    }

    qp->first = *t;
    sipReleaseType(t, sipType_TYPE, state);

    qp->second = SIPLong_AsLong(PyTuple_GET_ITEM(sipPy, 1));

    *sipCppPtr = qp;

    return sipGetState(sipTransferObj);
%End
};
%End
