// qstringlist.sip generated by MetaSIP
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2015 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt4.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qstringlist.h>
%End

// class QStringList /API=QString:2 -,DocType="list-of-str"/
%MappedType QStringList /API=QString:2 -,DocType="list-of-str"/
{
%TypeHeaderCode
#include <qstringlist.h>
%End

%ConvertToTypeCode
if (sipIsErr == NULL)
    return qpycore_PySequence_Check_QStringList(sipPy);

*sipCppPtr = new QStringList(qpycore_PySequence_AsQStringList(sipPy));

return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
    return qpycore_PyObject_FromQStringList(*sipCpp);
%End
};

class QStringList /API=QString: - 2/
{
%TypeHeaderCode
#include <qstringlist.h>
%End

%ConvertToTypeCode
// Allow a Python sequence of QStrings whenever a QStringList is expected.

if (sipIsErr == NULL)
{
    if (sipCanConvertToType(sipPy, sipType_QStringList, SIP_NO_CONVERTORS))
        return 1;

    return qpycore_PySequence_Check_QStringList(sipPy);
}

if (sipCanConvertToType(sipPy, sipType_QStringList, SIP_NO_CONVERTORS))
{
    *sipCppPtr = reinterpret_cast<QStringList *>(sipConvertToType(sipPy, sipType_QStringList, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

    return 0;
}

*sipCppPtr = new QStringList(qpycore_PySequence_AsQStringList(sipPy));

return sipGetState(sipTransferObj);
%End

public:
    QStringList();
    explicit QStringList(const QString &i);
    QStringList(const QStringList &l);
    QStringList &operator<<(const QString &str);
    QStringList &operator<<(const QStringList &l);
%If (Qt_5_0_0 -)
    void sort(Qt::CaseSensitivity cs = Qt::CaseSensitive);
%End
%If (- Qt_5_0_0)
    void sort();
%End
    QString join(const QString &sep) const;
    QStringList filter(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%If (Qt_5_0_0 -)
    bool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
%If (- Qt_5_0_0)
    QBool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
%End
    QStringList &replaceInStrings(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QStringList &replaceInStrings(const QRegExp &rx, const QString &after);
    QStringList filter(const QRegExp &rx) const;
    int indexOf(const QString &value, int from = 0) const;
    int indexOf(const QRegExp &rx, int from = 0) const;
    int lastIndexOf(const QString &value, int from = -1) const;
    int lastIndexOf(const QRegExp &rx, int from = -1) const;
%If (Qt_4_5_0 -)
    int removeDuplicates();
%End
    void __setitem__(int i, const QString &str);
%MethodCode
        int len;
        
        len = sipCpp->count();
        
        if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            (*sipCpp)[a0] = *a1;
%End

    void __setitem__(SIP_PYSLICE slice, const QStringList &list);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength, i;
        
        len = sipCpp->count();
        
        #if PY_VERSION_HEX >= 0x03020000
        if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
        #else
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
        #endif
            sipIsErr = 1;
        else
        {
            int vlen = a1->count();
        
            if (vlen != slicelength)
            {
                sipBadLengthForSlice(vlen, slicelength);
                sipIsErr = 1;
            }
            else
            {
                QStringList::const_iterator it = a1->begin();
        
                for (i = 0; i < slicelength; ++i)
                {
                    (*sipCpp)[start] = *it;
                    start += step;
                    ++it;
                }
            }
        }
%End

    void __delitem__(int i);
%MethodCode
        int len;
        
        len = sipCpp->count();
        
        if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            sipCpp->removeAt(a0);
%End

    void __delitem__(SIP_PYSLICE slice);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength, i;
        
        len = sipCpp->count();
        
        #if PY_VERSION_HEX >= 0x03020000
        if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
        #else
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
        #endif
            sipIsErr = 1;
        else
            for (i = 0; i < slicelength; ++i)
            {
                sipCpp->removeAt(start);
                start += step - 1;
            }
%End

    QString operator[](int i);
%MethodCode
        SIP_SSIZE_T idx = sipConvertFromSequenceIndex(a0, sipCpp->count());
        
        if (idx < 0)
            sipIsErr = 1;
        else
            sipRes = new QString(sipCpp->operator[]((int)idx));
%End

    QStringList operator[](SIP_PYSLICE slice);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength, i;
        
        len = sipCpp->count();
        
        #if PY_VERSION_HEX >= 0x03020000
        if (PySlice_GetIndicesEx(a0, len, &start, &stop, &step, &slicelength) < 0)
        #else
        if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
        #endif
            sipIsErr = 1;
        else
        {
            sipRes = new QStringList();
        
            for (i = 0; i < slicelength; ++i)
            {
                (*sipRes) += (*sipCpp)[start];
                start += step;
            }
        }
%End

    int __contains__(const QString &str);
%MethodCode
        // It looks like you can't assign QBool to int.
        sipRes = bool(sipCpp->contains(*a0));
%End

    QStringList operator+(const QStringList &other) const;
    QStringList operator*(int by);
%MethodCode
        sipRes = new QStringList();
        
        while (a0-- > 0)
            *sipRes += *sipCpp;
%End

    QStringList &operator*=(int by);
%MethodCode
        QStringList orig(*sipCpp);
        
        sipCpp->clear();
        
        while (a0-- > 0)
            *sipCpp += orig;
%End

    bool operator==(const QStringList &other);
    bool operator!=(const QStringList &other);
// Methods inherited from QList<QString>.
// Keep this in sync with QItemSelection.
void clear();
bool isEmpty() const;
void append(const QString &str);
void prepend(const QString &str);
void insert(int i, const QString &str);
void replace(int i, const QString &str);
void removeAt(int i);
int removeAll(const QString &str);
QString takeAt(int i);
QString takeFirst();
QString takeLast();
void move(int from, int to);
void swap(int i, int j);
int count(const QString &str) const;
int count() const /__len__/;
QString &first();
QString &last();
QStringList mid(int pos, int length = -1) const;
QStringList &operator+=(const QStringList &other);
QStringList &operator+=(const QString &value);
};

QDataStream &operator>>(QDataStream &in, QStringList &list /Constrained/) /API=QString: - 2/;
QDataStream &operator<<(QDataStream &out, const QStringList &list /Constrained/) /API=QString: - 2/;
